import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'package:crypto/crypto.dart';
import 'package:encrypt/encrypt.dart' as e;
import 'package:flutter/services.dart';
import 'package:path/path.dart' as p;

class PermissionError extends Error {
  final String message;
  PermissionError(this.message);
  @override
  String toString() => message;
}
class VaultsManager {
  static List<Vault> storedVaults = [];
  static late final String appFolder;
  static late final File mainConfigFile;

  static void saveVaults() {
    mainConfigFile.writeAsStringSync(jsonEncode(
        {
          "chests": [
            for(Vault vault in storedVaults)
              vault.toJson()
          ]
        }
    ));

    for(Vault vault in storedVaults) {
      File recognizerFile = File(vault.filesMetadataBankPath);
      recognizerFile.createSync(recursive: true);
      recognizerFile.writeAsStringSync(vault.toRawJson());
    }
  }

  static void loadVaults() {
    late Map<String, dynamic> chests;

    try {
      chests = jsonDecode(mainConfigFile.readAsStringSync());
    } on FormatException {
      chests = {'chests': []};
    }

    List<Vault> constructedVaults = [];
    for(Map<String, dynamic> chest in chests['chests']) {
      constructedVaults.add(Vault.fromJson(chest));
    }
    storedVaults = constructedVaults;
  }

   static Future<Vault> createVaultFromPolicy(VaultPolicy policy) async {
    String path = p.join(VaultsManager.appFolder, '.${md5RandomFileName()}');
    // Do not edit the witness test file, please I beg you
    File keyFile = File(p.join(path, '.witness'));
    keyFile.createSync(recursive: true);
    e.Key cryptKey = e.Key.fromUtf8(passwordToCryptKey(policy.vaultPassword));
    // NOTE: An IV is not needed here as the first block of an encryption won't really matter because the data structure generated by this app is known.
    e.Encrypter cipher = e.Encrypter(e.AES(cryptKey, mode: e.AESMode.cbc));
    e.Encrypted encryptedWitnessFile = cipher.encrypt(await rootBundle.loadString('file_settings/encryption_witness_file', cache: false), iv: e.IV.fromLength(16));
    File witnessFile = File(p.join(path, '.witness'));
    witnessFile.createSync(recursive: true);
    witnessFile.writeAsStringSync(encryptedWitnessFile.base64);

    Vault createdVault = Vault(
      locked: false,
      creationDate: DateTime.now(),
      filesMetadataBankPath: p.join(path, '.${md5RandomFileName()}'),
      path: path,
      name: policy.vaultName,
      shouldDisconnectWhenVaultOpened: policy.shouldDisconnectWhenVaultOpened,
      automaticallyCloseVaultOnTimeout: policy.automaticallyCloseVaultOnTimeout,
      timeout: policy.vaultTimeout,
      encryptionKey: cryptKey
    );

    File mapFile = File(p.join(path, '.map'));
    mapFile.createSync(recursive: true);

    mapFile.writeAsStringSync(encryptMap(createdVault, constructMap(createdVault))!);

    return createdVault;
  }

  static void deleteVault(Vault vault) {
    saveVaults();
    storedVaults.remove(vault);
    Directory folderToDelete = Directory(vault.path);

    folderToDelete.deleteSync(recursive: true);
    saveVaults();
  }

  static Future<bool> testVaultKey(Vault vault) async {
    File witnessFile = File(p.join(vault.path, '.witness'));

    if(vault.encryptionKey == null || !witnessFile.existsSync()) return false;

    e.Encrypter cipher = e.Encrypter(e.AES(vault.encryptionKey!, mode: e.AESMode.cbc));
    String decryptedWitnessFile;
    try {
      decryptedWitnessFile = cipher.decrypt64(witnessFile.readAsStringSync(), iv: e.IV.fromLength(16));
    } on ArgumentError {
      return false;
    }

    return decryptedWitnessFile == await rootBundle.loadString('file_settings/encryption_witness_file', cache: false);
  }

  static Map<String, dynamic> constructMap(Vault vault, {Map<String, dynamic>? oldMap, Map<String, String>? additionalFiles}) {
    Map<String, dynamic> newMap = {};
    oldMap ??= {};
    additionalFiles ??= {};
    for(FileSystemEntity file in Directory(vault.path).listSync()) {
      String localPath = file.path.substring(vault.path.length + 1);

      if(localPath.startsWith('.')) continue;

      newMap[localPath] = 'unknown';
    }

    for(MapEntry<String, dynamic> oldFile in oldMap.entries.toList()..addAll(additionalFiles.entries)) {
      if(newMap[oldFile.key] != null) {
        newMap[oldFile.key] = oldFile.value;
      }
    }
    return newMap;
  }

  static String? encryptMap(Vault vault, Map<String, dynamic> initialMap) {
    if(vault.encryptionKey == null) return null;

    e.Encrypter cipher = e.Encrypter(e.AES(vault.encryptionKey!, mode: e.AESMode.cbc));
    return cipher.encrypt(jsonEncode(initialMap), iv: e.IV.fromLength(16)).base64;
  }

  static Map<String, dynamic>? decryptMap(Vault vault, String encryptedMap) {
    if(vault.encryptionKey == null) return null;

    e.Encrypter cipher = e.Encrypter(e.AES(vault.encryptionKey!, mode: e.AESMode.cbc));
    Map<String, dynamic> decryptedMap = jsonDecode(cipher.decrypt64(encryptedMap, iv: e.IV.fromLength(16)));

    return decryptedMap;
  }
}

class VaultPolicy {
  bool isInternalVault;
  String vaultName;
  String vaultPassword;
  bool shouldDisconnectWhenVaultOpened;
  Duration? vaultTimeout;
  bool? automaticallyCloseVaultOnTimeout; // If false a notification will be sent
  bool isTimeoutEnabled;

  VaultPolicy(
    {
      this.isInternalVault = true, 
      this.vaultName = 'Unnamed vault',
      this.vaultPassword = '', 
      this.shouldDisconnectWhenVaultOpened = false, 
      this.vaultTimeout = const Duration(minutes: 15),
      this.automaticallyCloseVaultOnTimeout = false,
      this.isTimeoutEnabled = false,
    }
  );
}


String md5RandomFileName() {
  final randomNumber = Random.secure().nextDouble();
  final randomBytes = utf8.encode(randomNumber.toString());
  final randomString = md5.convert(randomBytes).toString();
  return randomString;
}

String passwordToCryptKey(String password) {
  final passwordBytes = utf8.encode(password);
  return md5.convert(passwordBytes).toString();
}

/// Represents a vault data-wise
class Vault {
  Vault(
    {
      required this.locked, 
      required this.path,
      required this.creationDate, 
      required this.filesMetadataBankPath,
      required this.name,
      required this.shouldDisconnectWhenVaultOpened,
      this.timeout,
      this.automaticallyCloseVaultOnTimeout,
      this.encryptionKey
    }
  );

  Vault.fromJson(Map<String, dynamic> storedData) {
    locked = storedData['locked'];
    path = storedData['path'];
    creationDate = DateTime.fromMillisecondsSinceEpoch(storedData['creation_date']);
    filesMetadataBankPath = storedData['files_metadata_bank_path'];
    name = storedData['name'];
    shouldDisconnectWhenVaultOpened = storedData['should_disconnect_when_vault_opened'];
    timeout = Duration(seconds: storedData['timeout']);
    automaticallyCloseVaultOnTimeout = storedData['automatically_close_vault_on_timeout'];
  }

  Map<String, dynamic> toJson() {
    return
        {
          'locked': locked,
          'path': path,
          'creation_date': creationDate.millisecondsSinceEpoch,
          'files_metadata_bank_path': filesMetadataBankPath,
          'name': name,
          'should_disconnect_when_vault_opened': shouldDisconnectWhenVaultOpened,
          'timeout': timeout?.inSeconds,
          'automatically_close_vault_on_timeout': automaticallyCloseVaultOnTimeout
        }
    ;
  }

  String toRawJson() {
    return jsonEncode(toJson());
  }

  /// If the vault is locked or not
  late bool locked;
  /// The path of the folder containing all the encrypted files
  late String path;
  /// When the vault has been created
  late DateTime creationDate;
  /// Where is the file who contains all encrypted files outer data like it's real creation date it's name and other things to restore when the chest is opened
  late String filesMetadataBankPath;
  /// The visual name of the chest
  late String name;
  /// Should the phone enter airplane mode when the chest is opened
  late bool shouldDisconnectWhenVaultOpened;
  /// The amount of time the chest is kept opened (if applicable)
  late Duration? timeout;
  /// Should the vault be closed when the timeout has passed, if not a notification will be sent to the user to see if it wants to close the vault
  late bool? automaticallyCloseVaultOnTimeout;
  /// The decryption key used to read files
  late e.Key? encryptionKey;
}